# JAM-006: API Route Structure

**Priority**: ðŸŸ¡ High
**Effort**: 2-3 hours
**Dependencies**: JAM-001 (database)
**Status**: âœ… PARTIALLY COMPLETE

## ðŸ“‹ Objective

Set up the foundational API routes for the Jam platform. Create a consistent structure for all platform endpoints with proper error handling and authentication middleware.

## âœ… Acceptance Criteria

- [x] API route structure organized
- [ ] Authentication middleware working (N/A - using client-side Privy auth)
- [x] Error handling standardized
- [x] Basic CRUD operations for core entities
- [x] Response format consistent
- [ ] Rate limiting setup (basic) - DEFERRED to production

## ðŸŽ¯ Current Architecture (Implemented)

### What We Built

**Response Utilities** (`src/lib/api/responses.ts`):
- `successResponse()` - Standard success format
- `errorResponse()` - Standard error format
- `createdResponse()` - 201 Created
- `paginatedResponse()` - Paginated data
- Helper functions: `badRequestResponse()`, `notFoundResponse()`, `forbiddenResponse()`, etc.

**Error Classes** (`src/lib/api/errors.ts`):
- `ValidationError` - 400 Bad Request
- `UnauthorizedError` - 401 Unauthorized
- `ForbiddenError` - 403 Forbidden
- `NotFoundError` - 404 Not Found
- `ConflictError` - 409 Conflict
- `TooManyRequestsError` - 429 Rate Limit
- `InternalServerError` - 500 Server Error

**API Routes Implemented**:
- `/api/jam/projects` - GET, POST, PATCH
- `/api/jam/projects/[slug]` - GET
- `/api/jam/projects/[slug]/members` - GET
- `/api/jam/projects/[slug]/programs` - GET
- `/api/jam/dashboard` - GET
- `/api/jam/profile` - GET, PATCH

**Service Layer** (`src/lib/jam/`):
- `projects.ts` - Project utilities (slug generation, queries)
- `onboarding.ts` - Onboarding utilities
- `dashboard.ts` - Dashboard data aggregation

### Architecture Decisions

1. **No API Authentication Middleware**: Using client-side Privy authentication, not JWT tokens
2. **TanStack Query on Frontend**: All API calls use React Query for caching/state
3. **Next.js 15 Async Params**: All dynamic routes use `Promise<{ param }>` pattern
4. **Transaction-Based Operations**: Multi-table operations use Drizzle transactions
5. **Service Layer Pattern**: Business logic in `/lib/jam/`, routes stay thin

## ðŸ› ï¸ Implementation

### Files to Create/Modify
- `src/app/api/jam/` - All Jam platform APIs
- `src/lib/api/middleware.ts` - Auth & error handling
- `src/lib/api/responses.ts` - Standardized responses
- `src/lib/api/errors.ts` - Error classes

### API Structure

```
src/app/api/jam/
â”œâ”€â”€ auth/
â”‚   â””â”€â”€ route.ts           # Auth endpoints
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ route.ts          # GET users, POST user
â”‚   â””â”€â”€ [id]/route.ts     # GET, PUT, DELETE user
â”œâ”€â”€ projects/
â”‚   â”œâ”€â”€ route.ts          # GET projects, POST project
â”‚   â””â”€â”€ [id]/route.ts     # GET, PUT project
â”œâ”€â”€ quests/
â”‚   â”œâ”€â”€ route.ts          # GET quests
â”‚   â””â”€â”€ [id]/
â”‚       â”œâ”€â”€ route.ts      # GET quest details
â”‚       â””â”€â”€ submit/route.ts # POST submission
â”œâ”€â”€ programs/
â”‚   â”œâ”€â”€ route.ts          # GET programs
â”‚   â””â”€â”€ [id]/
â”‚       â”œâ”€â”€ route.ts      # GET program
â”‚       â””â”€â”€ join/route.ts # POST join program
â”œâ”€â”€ mentors/
â”‚   â”œâ”€â”€ route.ts          # GET mentors
â”‚   â””â”€â”€ connect/route.ts  # POST mentor request
â””â”€â”€ posts/
    â””â”€â”€ route.ts          # GET, POST community posts
```

### Authentication Middleware

```typescript
// src/lib/api/middleware.ts
export async function authenticate(request: Request) {
  const token = request.headers.get('authorization')?.split(' ')[1];
  
  if (!token) {
    throw new UnauthorizedError('No token provided');
  }
  
  try {
    const userId = await verifyToken(token);
    const user = await getUserById(userId);
    
    if (!user) {
      throw new UnauthorizedError('User not found');
    }
    
    return user;
  } catch (error) {
    throw new UnauthorizedError('Invalid token');
  }
}

export function withAuth(handler: Function) {
  return async (request: Request, ...args: any[]) => {
    try {
      const user = await authenticate(request);
      request.user = user;
      return handler(request, ...args);
    } catch (error) {
      return errorResponse(error);
    }
  };
}
```

### Standardized Responses

```typescript
// src/lib/api/responses.ts
export function successResponse(data: any, message = 'Success') {
  return NextResponse.json({
    success: true,
    message,
    data
  });
}

export function errorResponse(error: any) {
  const status = error.status || 500;
  const message = error.message || 'Internal server error';
  
  return NextResponse.json({
    success: false,
    message,
    error: process.env.NODE_ENV === 'development' ? error.stack : undefined
  }, { status });
}

export function paginatedResponse(
  data: any[],
  page: number,
  limit: number,
  total: number
) {
  return NextResponse.json({
    success: true,
    data,
    pagination: {
      page,
      limit,
      total,
      hasMore: page * limit < total
    }
  });
}
```

### Example API Route

```typescript
// src/app/api/jam/projects/route.ts
import { withAuth } from '@/lib/api/middleware';

export const GET = withAuth(async (request: Request) => {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '10');
  
  const projects = await db.select()
    .from(projectsTable)
    .limit(limit)
    .offset((page - 1) * limit);
    
  const total = await db.count(projectsTable);
  
  return paginatedResponse(projects, page, limit, total);
});

export const POST = withAuth(async (request: Request) => {
  const data = await request.json();
  const userId = request.user.id;
  
  // Validate input
  if (!data.name || !data.description) {
    throw new ValidationError('Name and description required');
  }
  
  // Check existing project
  const existing = await getUserProject(userId);
  if (existing) {
    throw new ConflictError('User already has a project');
  }
  
  // Create project
  const project = await createProject(userId, data);
  
  return successResponse(project, 'Project created successfully');
});
```

### Rate Limiting

```typescript
// src/lib/api/rateLimiter.ts
const attempts = new Map();

export function rateLimit(maxAttempts = 10, windowMs = 60000) {
  return (request: Request) => {
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    const key = `${ip}:${request.url}`;
    
    const now = Date.now();
    const userAttempts = attempts.get(key) || [];
    
    // Clean old attempts
    const validAttempts = userAttempts.filter(
      (time: number) => now - time < windowMs
    );
    
    if (validAttempts.length >= maxAttempts) {
      throw new TooManyRequestsError('Rate limit exceeded');
    }
    
    validAttempts.push(now);
    attempts.set(key, validAttempts);
  };
}
```

## ðŸŽ¯ Testing

1. **Auth middleware**
   - Protected routes require token
   - Invalid tokens rejected
   - User attached to request

2. **Error handling**
   - Errors return proper status codes
   - Development shows stack traces
   - Production hides sensitive info

3. **CRUD operations**
   - Create, Read, Update, Delete work
   - Validation errors caught
   - Database errors handled

## ðŸ’¡ Notes

- Keep routes RESTful and predictable
- Use proper HTTP status codes
- Validate input before database operations
- Consider using Zod for schema validation later

## ðŸš¨ Potential Issues

- **CORS**: Configure for frontend URL
- **File uploads**: Need different handling
- **Rate limiting**: May need Redis for production
- **Error logging**: Consider Sentry integration later