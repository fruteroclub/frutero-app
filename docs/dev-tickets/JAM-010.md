# JAM-010: Mentor Directory & Matching

**Priority**: üî¥ Critical  
**Effort**: 4-5 hours  
**Dependencies**: JAM-006 (API structure)

## üìã Objective

Create a system for discovering mentors and requesting mentorship connections. This is the core of the platform - connecting participants with experienced mentors.

## ‚úÖ Acceptance Criteria

- [ ] Mentor directory with profiles
- [ ] Filter mentors by expertise, track, availability
- [ ] Mentor profile pages
- [ ] Connection request system
- [ ] Basic matching suggestions
- [ ] Mentor availability status

## üõ†Ô∏è Implementation

### Files to Create/Modify

- `src/app/jam/mentors/page.tsx` - Mentor directory
- `src/app/jam/mentors/[id]/page.tsx` - Mentor profile
- `src/components/jam-platform/mentors/` - Mentor components
- `src/app/api/jam/mentors/route.ts` - Mentor API
- `src/app/api/jam/mentorships/route.ts` - Connection API

### Mentor Directory

```tsx
// src/app/jam/mentors/page.tsx
export default async function MentorsPage() {
  const mentors = await getAvailableMentors()
  const recommendations = await getMentorRecommendations()

  return (
    <div className="container py-6">
      <div className="mb-6 flex items-center justify-between">
        <h1 className="text-3xl font-bold">Find Your Mentor</h1>
        <MentorFilters />
      </div>

      {recommendations.length > 0 && (
        <div className="mb-8">
          <h2 className="mb-4 text-xl font-semibold">Recommended for You</h2>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {recommendations.map((mentor) => (
              <MentorCard key={mentor.id} mentor={mentor} recommended />
            ))}
          </div>
        </div>
      )}

      <div>
        <h2 className="mb-4 text-xl font-semibold">All Mentors</h2>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {mentors.map((mentor) => (
            <MentorCard key={mentor.id} mentor={mentor} />
          ))}
        </div>
      </div>
    </div>
  )
}
```

### Mentor Card Component

```tsx
// src/components/jam-platform/mentors/MentorCard.tsx
export function MentorCard({ mentor, recommended = false }) {
  return (
    <Card className="transition-shadow hover:shadow-lg">
      {recommended && (
        <div className="bg-primary text-primary-foreground px-3 py-1 text-center text-xs">
          Recommended for you
        </div>
      )}

      <CardHeader>
        <div className="flex items-start gap-3">
          <Avatar className="h-12 w-12">
            <AvatarImage src={mentor.avatarUrl} />
            <AvatarFallback>{mentor.displayName.slice(0, 2).toUpperCase()}</AvatarFallback>
          </Avatar>

          <div className="flex-1">
            <CardTitle className="text-lg">{mentor.displayName}</CardTitle>
            <p className="text-foreground text-sm">{mentor.profile.primaryRole}</p>
            <div className="mt-1 flex items-center gap-2">
              <AvailabilityBadge
                status={mentor.availability}
                capacity={mentor.currentParticipants}
                maxCapacity={mentor.maxParticipants}
              />
              <div className="flex items-center gap-1">
                <Star className="h-3 w-3 fill-yellow-400 text-yellow-400" />
                <span className="text-xs">{mentor.rating.toFixed(1)}</span>
              </div>
            </div>
          </div>
        </div>
      </CardHeader>

      <CardContent>
        <p className="text-foreground mb-3 line-clamp-2 text-sm">{mentor.bio}</p>

        <div className="mb-3 flex flex-wrap gap-1">
          {mentor.expertiseAreas.slice(0, 3).map((area) => (
            <Badge key={area} variant="secondary" className="text-xs">
              {area}
            </Badge>
          ))}
          {mentor.expertiseAreas.length > 3 && (
            <Badge variant="outline" className="text-xs">
              +{mentor.expertiseAreas.length - 3} more
            </Badge>
          )}
        </div>

        <div className="flex gap-2">
          <Button variant="outline" size="sm" className="flex-1" asChild>
            <Link href={`/jam/mentors/${mentor.id}`}>View Profile</Link>
          </Button>

          {mentor.availability === 'available' && (
            <Button size="sm" onClick={() => requestConnection(mentor.id)}>
              Connect
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  )
}
```

### Mentor Profile Page

```tsx
// src/app/jam/mentors/[id]/page.tsx
export default async function MentorProfilePage({ params }) {
  const mentor = await getMentorProfile(params.id)
  const testimonials = await getMentorTestimonials(params.id)
  const currentUser = await getCurrentUser()
  const connectionStatus = await getConnectionStatus(currentUser.id, params.id)

  return (
    <div className="container max-w-4xl py-6">
      <MentorProfileHeader mentor={mentor} />

      <div className="mt-6 grid gap-6 md:grid-cols-3">
        <div className="space-y-6 md:col-span-2">
          <MentorBio bio={mentor.bio} />
          <MentorExperience experience={mentor.experience} />
          <MentorApproach approach={mentor.mentoringApproach} />
          <MentorTestimonials testimonials={testimonials} />
        </div>

        <div className="space-y-4">
          <MentorConnectionCard mentor={mentor} connectionStatus={connectionStatus} />
          <MentorExpertise expertise={mentor.expertiseAreas} />
          <MentorAvailability schedule={mentor.availability} />
          <MentorStats
            rating={mentor.rating}
            sessions={mentor.totalSessions}
            participants={mentor.totalParticipants}
          />
        </div>
      </div>
    </div>
  )
}
```

### Connection Request System

```tsx
// src/components/jam-platform/mentors/ConnectionRequest.tsx
export function ConnectionRequestModal({ mentor, onClose }) {
  const [message, setMessage] = useState('')
  const [goals, setGoals] = useState('')

  const handleSubmit = async (e) => {
    e.preventDefault()

    await submitConnectionRequest({
      mentorId: mentor.id,
      message,
      goals,
      participantInfo: {
        track: user.track,
        experience: user.experience,
        project: user.project,
      },
    })

    toast.success('Connection request sent!')
    onClose()
  }

  return (
    <Dialog open onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Connect with {mentor.displayName}</DialogTitle>
          <DialogDescription>Tell them why you'd like to work together</DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label>Why do you want this mentor?</Label>
            <Textarea
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="What drew you to their profile? What do you hope to learn?"
              required
            />
          </div>

          <div>
            <Label>Your Goals</Label>
            <Textarea
              value={goals}
              onChange={(e) => setGoals(e.target.value)}
              placeholder="What do you want to achieve in the next 6 weeks?"
              required
            />
          </div>

          <div className="flex gap-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button type="submit">Send Request</Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

### Mentor Matching Logic

```typescript
// src/lib/jam/mentors.ts
export async function getMentorRecommendations(userId: string) {
  const user = await getUserWithProfile(userId)

  const mentors = await db
    .select()
    .from(usersTable)
    .innerJoin(profilesTable, eq(usersTable.id, profilesTable.userId))
    .where(and(eq(usersTable.isMentor, true), eq(usersTable.mentorAvailability, 'available')))

  // Score mentors based on:
  // 1. Track alignment
  // 2. Expertise match
  // 3. Geographic proximity
  // 4. Language match
  // 5. Availability

  return mentors
    .map((mentor) => ({
      ...mentor,
      score: calculateMatchScore(user, mentor),
    }))
    .sort((a, b) => b.score - a.score)
    .slice(0, 3)
}

function calculateMatchScore(participant, mentor) {
  let score = 0

  // Track alignment (30%)
  if (mentor.expertiseTracks.includes(participant.track)) {
    score += 30
  }

  // Expertise match (25%)
  const expertiseMatch = mentor.expertiseAreas.filter((area) =>
    participant.interests?.includes(area),
  ).length
  score += Math.min(expertiseMatch * 5, 25)

  // Availability (20%)
  if (mentor.currentParticipants < mentor.maxParticipants) {
    score += 20
  }

  // Rating (15%)
  score += (mentor.rating / 5) * 15

  // Geographic proximity (10%)
  if (mentor.country === participant.country) {
    score += 10
  }

  return score
}
```

## üéØ Testing

1. **Mentor discovery**
   - All mentors display
   - Filters work correctly
   - Recommendations appear

2. **Connection requests**
   - Form validates properly
   - Requests sent successfully
   - Status updates correctly

3. **Mentor profiles**
   - All information displays
   - Contact actions work
   - Testimonials load

## üí° Notes

- Start with manual mentor approval
- Consider video intro later
- Track success metrics by mentor
- Allow mentor preferences for participant types

## üö® Potential Issues

- **Mentor capacity**: Prevent overloading
- **Request spam**: Rate limit requests
- **Profile completeness**: Require minimum info
- **Availability updates**: Keep status current
